<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
  <title>TestML - A Software Testing Meta Language</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico">
  <link rel="stylesheet" href="/project-site.css" type="text/css">
  <link rel="stylesheet" href="/custom.css" type="text/css">
  <script type="text/javascript" src="/js/jquery.js"></script>
  <script type="text/javascript" src="/js/sidebar.js"></script>
</head>

<body>
<div class="page">
<div class="header">
  <a href="/"><img class="logo" src="/images/logo.png" alt=""></a>
</div>

<div class="bottom">
<div class="sidebar">
  <ul>
    <li><a href="/home/">Home</a></li>
    <li><a href="/specification/">Specifications</a>
      <ul>
        <li><a href="/specification/language/">Language Spec</a></li>
        <li><a href="/specification/standard-library/">Standard Library Spec</a></li>
        <li><a href="/specification/runtime/">Runtime Spec</a></li>
      </ul>
    </li>
    <li><a href="/documentation/">Documentation</a>
      <ul>
        <li><a href="/documentation/quick/">Quick Learner's Guide</a></li>
        <li><a href="/documentation/user-manual/">User's Manual</a></li>
        <li><a href="/documentation/implementor-guide/">Implementor's Guide</a></li>
      </ul>
    </li>
    <li><a href="/download/">Download</a></li>
    <li><a href="/community/">Community</a></li>
  </ul>
</div>

<div class="content">
<img class="photo" src="/images/chris-dent.jpg" alt="">


<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#testml">TestML</a></li>
	<li><a href="#status">Status</a></li>
	<li><a href="#overview">Overview</a></li>
	<li><a href="#history">History</a></li>
	<li><a href="#design_goals">Design Goals</a></li>
	<li><a href="#terminology">Terminology</a></li>
	<li><a href="#the_specification">The Specification</a></li>
	<ul>

		<li><a href="#document_encoding">Document Encoding</a></li>
		<li><a href="#pegex_syntax_review">Pegex Syntax Review</a></li>
		<li><a href="#pegex_grammar_primitives">Pegex Grammar Primitives</a></li>
		<li><a href="#grammar_tokens">Grammar Tokens</a></li>
		<li><a href="#top_level_document_grammar">Top Level Document Grammar</a></li>
		<ul>

			<li><a href="#meta_section_of_the_grammar">Meta Section of the Grammar</a></li>
			<li><a href="#test_section_of_the_grammar">Test Section of the Grammar</a></li>
			<li><a href="#data_section_of_the_grammar">Data Section of the Grammar</a></li>
		</ul>

	</ul>

	<li><a href="#core_meta_keywords">Core Meta Keywords</a></li>
	<li><a href="#testml_standard_library">TestML Standard Library</a></li>
	<li><a href="#testml_runtime_specification">TestML Runtime Specification</a></li>
	<li><a href="#authors">Authors</a></li>
	<li><a href="#license">License</a></li>
	<li><a href="#copyright">Copyright</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="testml">TestML</a></h1>
<p>A Software Testing Meta Language</p>
<p>
</p>
<hr />
<h1><a name="status">Status</a></h1>
<p>Working Draft - 2 August, 2010</p>
<p>This document is the TestML Language Specification. Version 1.0
Pre-release.</p>
<p>This is not the final 1.0 release. It is very new, under
review, under revision and undergoing initial implementation and
testing.</p>
<p>
</p>
<hr />
<h1><a name="overview">Overview</a></h1>
<p><strong>TestML</strong> is a meta language for writing tests that define how a piece
of software should behave, regardless of the programming language the
software is written in.</p>
<p>It is primarily intended for generic libraries or modules that are
relevant in many languages, or that have multiple implementations in the
same language. In these scenarios the different implementations can all
use the exact same tests. However, TestML's clarity and ease of use may
make it desirable for testing all types of software.</p>
<p>TestML <em>documents</em> define a set of data points and a program written in
an abstract transform/assertion language that invokes the application
being tested. The <em>transform functions</em> alter given data points into
new states. Then assertions can be made between the altered data points
and expected result data points. Here is a simple, but complete, TestML
document example:</p>
<pre>
    %TestML: 1.0            # This is a TestML 1.0 test document.</pre>
<pre>
    # This statement asserts that the 'input' data points, transformed
    # to upper case, match the corresponding 'output' data points.
    *input.uppercase == *output;</pre>
<pre>
    # The following lines define 2 data blocks, with 2 data points each.
    === Test mixed case string
    --- input: I Like Pie
    --- output: I LIKE PIE</pre>
<pre>
    === Test lower case string
    --- input: i love lucy
    --- output: I LOVE LUCY</pre>
<p>In this case, a programmer of any given language would do the following:</p>
<ul>
<li><strong><a name="item_implement_an_application_that_can_turn_strings_to_">Implement an application that can turn strings to upper case.</a></strong>

</li>
<li><strong><a name="item_implement_a_testml__22bridge_class_22_that_defines">Implement a TestML ``bridge class'' that defines the 'uppercase'
transform function to invoke the application's upper casing facility.</a></strong>

</li>
<li><strong><a name="item_set_up_their_test_environment_to_use_testml_to_run">Set up their test environment to use TestML to run the test.</a></strong>

</li>
</ul>
<p>
</p>
<hr />
<h1><a name="history">History</a></h1>
<p>The concept of TestML was heavily inspired by Ward Cunningham's <strong>FIT</strong>
test framework. The primary difference is that FIT's test documents are
table/spreadsheet based, where TestML's are text file based. This reflects
the premise that FIT caters to business application development (where
spreadsheets are heavily used), while TestML caters to open source
library authors (where everything is in text files).</p>
<p>The specifics of TestML (especially the data format), evolved directly
from Ingy d√∂t Net's data-driven Perl testing framework, <strong>Test::Base</strong>.
Test::Base was written in 2004 and later ported to JavaScript. As Ingy
ported various libraries to other languages, he realized the potential
value of making the test suites reusable.</p>
<p>
</p>
<hr />
<h1><a name="design_goals">Design Goals</a></h1>
<p>TestML has the following Design Goals:</p>
<dl>
<dt><strong><a name="item_platform_agnosticism">Platform Agnosticism</a></strong></dt>

<dd>
<p>TestML strives to make no assumptions about the programming language,
environment, or testing framework it will be used in. In this way, the
same corpus of test documents can be used against multiple
implementations of equivalent software.</p>
</dd>
<dt><strong><a name="item_readability">Readability</a></strong></dt>

<dd>
<p>TestML lets you define tests that are easy for both you and others to
write, read and maintain. The format is intended to let the data points
and test conditions stand out, while keeping the implementation specific
details in the <em>bridge class</em>.</p>
</dd>
<dt><strong><a name="item_extensibility">Extensibility</a></strong></dt>

<dd>
<p>TestML has been designed with acknowledgement that it will need to
evolve to meet many various testing requirements. For this reason, every
document requires a TestML version number. Also the original grammar has
been made quite strict, leaving a lot of room for future extension.</p>
</dd>
<dt><strong><a name="item_ease_of_implementation">Ease of Implementation</a></strong></dt>

<dd>
<p>TestML is designed to be fairly easy to implement in various programming
languages.</p>
<p>The TestML project has a set of tests (written in TestML) that a TestML
implementation must pass to be compliant. See <a href="http://testml.org/tests/">http://testml.org/tests/</a>.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="terminology">Terminology</a></h1>
<p>TestML uses a number of specific terms. The following glossary lists the 
terms and defines their meanings.</p>
<dl>
<dt><strong><a name="item_application">Application</a></strong></dt>

<dd>
<p>The software that is being tested.</p>
</dd>
<dt><strong><a name="item_assertion">Assertion</a></strong></dt>

<dd>
<p>A <em>test assertion</em> is a statement in the <em>TestML document</em> that
compares <em>data expressions</em> using an <em>assertion operator</em>.</p>
</dd>
<dt><strong><a name="item_block">Block</a></strong></dt>

<dd>
<p>A <em>data block</em> is an object that contains a set of named <em>data
points</em>. The block usually has a short label phrase. When the
tests are run, the <em>runner class</em> will run each of the <em>test
assertions</em> against each of the <em>data blocks</em> that contain the <em>data
points</em> needed by the assertion.</p>
</dd>
<dt><strong><a name="item_bridge">Bridge</a></strong></dt>

<dd>
<p>Every test setup defines a class that connects named <em>transform
functions</em> to the software being tested. This is known as a <em>bridge
class</em>, because it bridges the test to the application or library.</p>
</dd>
<dt><strong><a name="item_document">Document</a></strong></dt>

<dd>
<p>A <em>TestML document</em> is a file containing <em>meta information</em>, <em>test
assertions</em> and <em>data blocks</em>. This specification describes the format
of such a document.</p>
</dd>
<dt><strong><a name="item_expression">Expression</a></strong></dt>

<dd>
<p>A <em>data expression</em> is a calling sequence of <em>data point</em> references,
<em>transform function</em> calls and string constants.</p>
<p>A <em>test assertion</em> compares the result of one or two data expressions.</p>
</dd>
<dt><strong><a name="item_meta">Meta</a></strong></dt>

<dd>
<p>A <em>TestML document</em> can define a number of key/value pairs which are
considered <em>meta data</em> and are used to instantiate a <em>meta object</em>
that the test code can later access.</p>
</dd>
<dt><strong><a name="item_operator">Operator</a></strong></dt>

<dd>
<p>A <em>testing operator</em> is a method that compares the final state of two
data points.</p>
<p>The currently defined operators are <code>OK</code>, <code>EQ(...)</code> (or <code>== ...</code>)
and <code>HAS(...)</code> (or <code>~~ ...</code>).</p>
</dd>
<dt><strong><a name="item_point">Point</a></strong></dt>

<dd>
<p>A <em>data point</em> is a named piece of data that belongs to a given <em>data
block</em>. All data points are assumed to start out as unicode strings,
although a <em>transform function</em> may turn them into anything else.</p>
</dd>
<dt><strong><a name="item_runner">Runner</a></strong></dt>

<dd>
<p>The TestML class that is responsible for running all the appropriate
tests. The runner class is subclassed to integrate into various existing
test frameworks in different programming language environments.</p>
</dd>
<dt><strong><a name="item_section">Section</a></strong></dt>

<dd>
<p>Every <em>TestML document</em> has three sections, a <em>meta section</em>, a <em>test
section</em> and a <em>data section</em>. The first specifies <em>meta information</em>
and the second defines the <em>test assertions</em> that the document is declaring.
The last section defines the <em>data blocks</em> against which the test assertions
are applied.</p>
</dd>
<dt><strong><a name="item_standard_library">Standard Library</a></strong></dt>

<dd>
<p>TestML defines a set of standard <em>transform functions</em> to perform
typical data manipulations or provide well known constant values.</p>
</dd>
<dt><strong><a name="item_statement">Statement</a></strong></dt>

<dd>
<p>A <em>test section</em> consists of a sequence of <em>test statements</em>.
Statements representing a line of executable code. Generally statements
consist of <em>data points</em>, <em>transform functions</em> and <em>test assertions</em>,
all chained together in execution order.</p>
</dd>
<dt><strong><a name="item_transform">Transform</a></strong></dt>

<dd>
<p>A <em>transform function</em> is a function that takes a <em>context object</em> as its first argument, and an optional list of <em>test expressions</em>, as its remaining arguments. The context object contains the result of the last transform. Thus transforms are chained together to form <em>test expressions</em>.</p>
<p>Transforms are supplied by the TestML <code>standard libarary</code> or a <em>bridge
class</em> that usually changes a <em>data point</em> from one form into another.
A transform can invoke functionality of the <em>application</em> it is
testing. The whole idea of TestML is that by passing a data point
through one or more transforms, you can make it equivalent to some other
data point, causing the test to pass.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="the_specification">The Specification</a></h1>
<p>The TestML Specification it is defined by a Pegex
(<a href="http://www.pegex.org">http://www.pegex.org</a>) grammar. The grammar can fully parse a TestML
document unless the data section is in <em>XML</em>, <em>YAML</em> or <em>JSON</em>, in
which case a separate parse for the data section would be needed.</p>
<p>NOTE: The grammar is slightly self-modifying. Certain meta settings in
      the document can change how the rest of the document is parsed.</p>
<p>
</p>
<h2><a name="document_encoding">Document Encoding</a></h2>
<p>All TestML documents are composed of the printable unicode character set
and <em>must</em> be encoded in UTF8. Any character that does not meet these
requirements must raise an exception.</p>
<p>
</p>
<h2><a name="pegex_syntax_review">Pegex Syntax Review</a></h2>
<p>This is a quick intro to the Pegex syntax used in the specification.</p>
<ul>
<li><strong><a name="item__27_5b_2e_2e_2e_5d_27__2d_brackets_indicate_groupi">'[...]' - Brackets indicate grouping</a></strong>

</li>
<li><strong><a name="item__27_28_2e_2e_2e_29_27__2d_parentheses_indicate_cap">'(...)' - Parentheses indicate capture grouping</a></strong>

</li>
<li><strong><a name="item__27_2fregexp_2f_27__2d_slashes_enclose_a_pcre_regu">'/regexp/' - Slashes enclose a PCRE regular expression</a></strong>

</li>
<li><strong><a name="item__27_2fx__3csubregexp_3e_y_2f_27__2d_regexps_can_be">'/x &lt;subregexp&gt; y/' - Regexps can be composed from other regexps</a></strong>

</li>
<li><strong><a name="item__27_3csubrule_3e_27__2d_subrule_match">'&lt;subrule&gt;' - Subrule match</a></strong>

</li>
<li><strong><a name="item__27_3c_26subrule_3e_27__2d_positive_subrule_lookah">'&lt;&amp;subrule&gt;' - Positive subrule lookahead</a></strong>

</li>
<li><strong><a name="item__27_3c_21subrule_3e_27__2d_negative_subrule_lookah">'&lt;!subrule&gt;' - Negative subrule lookahead</a></strong>

</li>
<li><strong><a name="item__27_7c_27__2d_alternation">'|' - Alternation</a></strong>

</li>
<li><strong><a name="item__27_2a_27__2d_zero_or_more">'*' - Zero or more</a></strong>

</li>
<li><strong><a name="item__27_2b_27__2d_one_or_more">'+' - One or more</a></strong>

</li>
<li><strong><a name="item__27_3f_27__2d_zero_or_one">'?' - Zero or one</a></strong>

</li>
<li><strong><a name="item__27_21_27__2d_negation">'!' - Negation</a></strong>

</li>
</ul>
<p>
</p>
<h2><a name="pegex_grammar_primitives">Pegex Grammar Primitives</a></h2>
<p>The following primitives are defined by Pegex in terms of their PCRE regexp
equivalents. They are listed here for completeness.</p>
<dl>
<dt><strong><a name="item_printable_3a__2f_5b_5cx09_5cx0a_5cx0d_5cx20_2d_5cx">PRINTABLE: /[\x09\x0A\x0D\x20-\x7E\xA0-\x{D7FF}\x{E000}-\x{FFFD}]/</a></strong></dt>

<dd>
<p>NOTE: Non-PRINTABLE characters are not allowed in a TestML stream. The
      following units do not allow them either, but they have been left
      out of the regexps for simplicity sake.</p>
</dd>
<dt><strong><a name="item_always_3a__2f_2f__23_always_match">ALWAYS: // # Always match</a></strong></dt>

<dt><strong><a name="item_all_3a__2f_5b_5cs_5cs_5d_2f__23_every_unicode_char">ALL: /[\s\S]/ # Every unicode character</a></strong></dt>

<dt><strong><a name="item_any_3a__2f_2e_2f__23_any_character_except_newline">ANY: /./ # Any character except newline</a></strong></dt>

<dt><strong><a name="item_blank_3a__2f_5b_5c__5ct_5d_2f__23_a_space_or_tab_c">BLANK: /[\ \t]/ # A space or tab character</a></strong></dt>

<dt><strong><a name="item_blanks_3a__2f_5c__5ct_2f__23_for_inclusion_in_char">BLANKS: /\ \t/ # For inclusion in character classes</a></strong></dt>

<dt><strong><a name="item_break_3a__2f_5cn_2f__23_a_newline_character">BREAK: /\n/ # A newline character</a></strong></dt>

<dt><strong><a name="item_eol_3a__2f_5cr_3f_5cn_2f__23_a_unix_or_dos_line_en">EOL: /\r?\n/ # A Unix or DOS line ending</a></strong></dt>

<dt><strong><a name="item_lower_3a__2f_5ba_2dz_5d_2f__23_lower_case_ascii_al">LOWER: /[a-z]/ # Lower case ASCII alphabetic character</a></strong></dt>

<dt><strong><a name="item_upper_3a__2f_5ba_2dz_5d_2f__23_upper_case_ascii_al">UPPER: /[A-Z]/ # Upper case ASCII alphabetic character</a></strong></dt>

<dt><strong><a name="item_word_3a__2f_5cw_2f__2d_ie__27_5ba_2dza_2dz0_2d9__5">WORD: /\w/ - ie '[A-Za-z0-9_]' # A ``word'' character</a></strong></dt>

<dt><strong><a name="item_digit_3a__2f_5b0_2d9_5d_2f__23_a_numeric_digit">DIGIT: /[0-9]/ # A numeric digit</a></strong></dt>

<dt><strong><a name="item_equal_3a__2f_3d_2f__23_an_equals_sign">EQUAL: /=/ # An equals sign</a></strong></dt>

<dt><strong><a name="item_tilde_3a__2f_7e_2f__23_a_tilde_character">TILDE: /~/ # A tilde character</a></strong></dt>

<dt><strong><a name="item_star_3a__2f_5c_2a_2f__23_an_asterisk">STAR: /\*/ # An asterisk</a></strong></dt>

<dt><strong><a name="item_dash_3a__2f_2d_2f__23_a_dash_character">DASH: /-/ # A dash character</a></strong></dt>

<dt><strong><a name="item_dot_3a__2f_5c_2e_2f__23_a_period_character">DOT: /\./ # A period character</a></strong></dt>

<dt><strong><a name="item_colon_3a__2f_3a_2f__23_a_colon_character">COLON: /:/ # A colon character</a></strong></dt>

<dt><strong><a name="item_semi_3a__2f_3b_2f__23_a_semicolon_character">SEMI: /;/ # A semicolon character</a></strong></dt>

<dt><strong><a name="item_octothorpe">HASH: /#/ # An octothorpe (or hash) character</a></strong></dt>

<dt><strong><a name="item_back_3a__2f_5c_5c_2f__23_a_backslash_character">BACK: /\\/ # A backslash character</a></strong></dt>

<dt><strong><a name="item_single_3a__2f_27_2f__23_a_single_quote_character">SINGLE: /'/ # A single quote character</a></strong></dt>

<dt><strong><a name="item_double_3a__2f_22_2f__23_a_double_quote_character">DOUBLE: /``/ # A double quote character</a></strong></dt>

<dt><strong><a name="item_lparen_3a__2f_5c_28_2f__23_a_left_parenthesis">LPAREN: /\(/ # A left parenthesis</a></strong></dt>

<dt><strong><a name="item_rparen_3a__2f_5c_29_2f__23_a_right_parenthesis">RPAREN: /\)/ # A right parenthesis</a></strong></dt>

<dt><strong><a name="item_lsquare_3a__2f_5c_5b_2f__23_a_left_square_bracket">LSQUARE: /\[/ # A left square bracket</a></strong></dt>

<dt><strong><a name="item_langle_3a__2f_3c_2f__23_a_left_angle_bracket">LANGLE: /&lt;/ # A left angle bracket</a></strong></dt>

</dl>
<p>
</p>
<h2><a name="grammar_tokens">Grammar Tokens</a></h2>
<p>This section defines common tokens used throughout the grammar.</p>
<dl>
<dt><strong><a name="item_escape_3a__2f_5b0nt_5d_2f">escape: /[0nt]/</a></strong></dt>

<dd>
<p>One of the escapable string characters</p>
</dd>
<dt><strong><a name="item_line_3a__3cany_3e_2a__3ceol_3e">line: &lt;ANY&gt;* &lt;EOL&gt;</a></strong></dt>

<dd>
<p>A line is a string of zero or more non break characters followed by
a line ending.</p>
</dd>
<dt><strong><a name="item_blank_line_3a__3cblank_3e_2a__3ceol_3e">blank_line: &lt;BLANK&gt;* &lt;EOL&gt;</a></strong></dt>

<dd>
<p>Blank lines are useful to space things out visually.</p>
</dd>
<dt><strong><a name="item_comment_3a__3chash_3e__3cline_3e">comment: &lt;HASH&gt; &lt;line&gt;</a></strong></dt>

<dd>
<p>Comments start with a '#' and go to the end of the line. Comments are
only allowed where specifically permitted by the grammar. Comments are
treated like insignificant whitespace and ignored by the parser.</p>
</dd>
<dt><strong><a name="item_ws_3a__3cblank_3e__7c__3ceol_3e__7c__3ccomment_3e">ws: &lt;BLANK&gt; | &lt;EOL&gt; | &lt;comment&gt;</a></strong></dt>

<dd>
<p>The <code>ws</code> token represents characters in the stream that can be
thrown away.</p>
</dd>
<dt><strong><a name="item_quoted_string_3a__3csingle_quoted_string_3e__7c__3">quoted_string: &lt;single_quoted_string&gt; | &lt;double_quoted_string&gt;</a></strong></dt>

<dd>
<p>A quoted string can use either single or double quotes.</p>
</dd>
<dt><strong><a name="item_single_quoted_string_3a__2f_28_3f_3a_3csingle_3e_2">single_quoted_string:
    /(?:&lt;SINGLE&gt;(([^&lt;BREAK&gt;&lt;BACK&gt;&lt;SINGLE&gt;]|&lt;BACK&gt;&lt;SINGLE&gt;|&lt;BACK&gt;&lt;BACK&gt;)*?)&lt;SINGLE&gt;)/</a></strong></dt>

<dd>
<p>A single quoted string encodes the characters placed between the pair of
single quotes. A backslash is used to encode a backslash or a single
quote character.</p>
<pre>
    'Won\'t you scratch\\slash my back?'</pre>
</dd>
<dt><strong><a name="item_double_quoted_string_3a__2f_28_3f_3a_3cdouble_3e_2">double_quoted_string:
    /(?:&lt;DOUBLE&gt;(([^&lt;BREAK&gt;&lt;BACK&gt;&lt;DOUBLE&gt;]|&lt;BACK&gt;&lt;DOUBLE&gt;|&lt;BACK&gt;&lt;BACK&gt;|&lt;BACK&gt;&lt;escape&gt;)*?)&lt;DOUBLE&gt;)/</a></strong></dt>

<dd>
<p>A double quoted string encodes the characters placed between the pair of
double quotes. A backslash is used to encode a backslash or a double
quote character, and also a tab, a newline or a null using the
characters 't', 'n' or '0' respectively.</p>
<pre>
    &quot;\tline 1\n\&quot;line\&quot; 2\n&quot;</pre>
</dd>
<dt><strong><a name="item_unquoted_string_3a__2f_28_5b_5e_3cblanks_3e_3cbrea">unquoted_string:
    /([^&lt;BLANKS&gt;&lt;BREAK&gt;&lt;HASH&gt;](?:[^&lt;BREAK&gt;&lt;HASH&gt;]*[^&lt;BLANKS&gt;&lt;BREAK&gt;&lt;HASH&gt;])?)/</a></strong></dt>

<dd>
<p>AN unquoted string is the first to last non-space characters on a line
before an optional comment.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="top_level_document_grammar">Top Level Document Grammar</a></h2>
<dl>
<dt><strong><a name="item_document_3a__3cmeta_section_3e__3ctest_section_3e_">document:
    &lt;meta_section&gt;
    &lt;test_section&gt;
    &lt;data_section&gt;?</a></strong></dt>

<dd>
<p>A TestML Document consists of 3 sections, a meta section followed by a
test section followed by an optional inline data section.</p>
<p>Here is an example document:</p>
<pre>
    # TestML document includes:</pre>
<pre>
    # Meta statements,
    %TestML: 1.0</pre>
<pre>
    # And test statements.
    *foo.upper == *bar;
    *foo == *bar.lower;</pre>
<pre>
    # And a data section that defines data blocks.
    === Test vowels
    --- foo: i ie ie
    --- bar: I IE IE</pre>
<pre>
    === Test consonants
    --- foo
    lk p
    --- bar
    LK P</pre>
</dd>
</dl>
<p>
</p>
<h3><a name="meta_section_of_the_grammar">Meta Section of the Grammar</a></h3>
<dl>
<dt><strong><a name="item_meta_section_3a__5b__3ccomment_3e__7c__3cblank_lin">meta_section:
    [ &lt;comment&gt; | &lt;blank_line&gt; ]*
    &lt;meta_testml_statement&gt;
    [ &lt;meta_statement&gt; | &lt;comment&gt; | &lt;blank_line&gt; ]*</a></strong></dt>

<dd>
<p>The meta section is the first section of the document. It must contain a
testml version statement, and that statement must be the first meta
statement declared.</p>
<p>The parsing of the meta section should instantiate a Meta object.</p>
</dd>
<dt><strong><a name="item_meta_testml_statement_3a__2f_25testml_3a_2f__3cbla">meta_testml_statement:
    /%TestML:/ &lt;BLANK&gt;+ &lt;testml_version&gt;
    [ &lt;BLANK&gt;+ &lt;comment&gt; | &lt;EOL&gt; ]</a></strong></dt>

<dd>
<p>The meta <code>testml</code> statement is required, must be the first meta
statement, and must specify a valid TestML release version number.</p>
</dd>
<dt><strong><a name="item_testml_version_3a__3cdigit_3e__3cdot_3e__3cdigit_3">testml_version: &lt;DIGIT&gt; &lt;DOT&gt; &lt;DIGIT&gt;+</a></strong></dt>

<dd>
<p>Currently the only valid version number is '1.0'.</p>
</dd>
<dt><strong><a name="item_meta_statement_3a__2f_25_2f__3cmeta_keyword_3e__2f">meta_statement:
    /%/ &lt;meta_keyword&gt; /:/ &lt;BLANK&gt;+ &lt;meta_value&gt;
    [ &lt;BLANK&gt;+ &lt;comment&gt; | &lt;EOL&gt; ]</a></strong></dt>

<dd>
<p>Meta statements are key/value pairs separated by a colon and a
BLANK.</p>
<p>NOTE: A given meta setting may affect the document parsing/grammar from
that point forward.</p>
</dd>
<dt><strong><a name="item__3cmeta_keyword_3e_3a__3ccore_meta_keyword_3e__7c_">&lt;meta_keyword&gt;: &lt;core_meta_keyword&gt; | &lt;user_meta_keyword&gt;</a></strong></dt>

<dd>
<p>Meta settings come in two forms. TestML defined core settings, and user
defined settings.</p>
</dd>
<dt><strong><a name="item_core_meta_keyword_3a__2f_28title_7cdata_7cplan_7cb">core_meta_keyword: /(Title|Data|Plan|BlockMarker|PointMarker)/</a></strong></dt>

<dd>
<p>The listed keywords represent the core meta settings supported in TestML
1.0. See <a href="#valid_meta_keywords">Valid Meta Keywords</a> for the definitions of them.</p>
</dd>
<dt><strong><a name="item_user_meta_keyword_3a__3clower_3e__3cword_3e_2a">user_meta_keyword: &lt;LOWER&gt; &lt;WORD&gt;*</a></strong></dt>

<dd>
<p>A user can make up their own meta settings, as long as they begin with a
lower case letter. These values are then available to the runtime code.</p>
</dd>
<dt><strong><a name="item_meta_value_3a__3cquoted_string_3e__7c__3cunquoted_">meta_value: &lt;quoted_string&gt; | &lt;unquoted_string&gt;</a></strong></dt>

<dd>
<p>A meta value is the value of the meta setting being defined. Some settings
like <code>data</code> are stored as arrays. Multiple statements with they same keyword
add an element to the array.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="test_section_of_the_grammar">Test Section of the Grammar</a></h3>
<p>This section of TestML is the mini, generic programming language. In a
nutshell, the language consists of a list of chained expressions, some
of which make assertions. The following statements are valid syntax:</p>
<pre>
    # Expressions:
    'string';
    function();
    Constant;
    *data_point;
    *data_point.transform;
    *data_point.transform1.transform2;
    *data.trans('string', &quot;string&quot;);
    *data1.trans1(*data2, 'str').trans2(*data3.trans3);</pre>
<pre>
    # Assertions:
    &lt;expression&gt; == 'string';
    &lt;expression&gt; == Constant;
    &lt;expression&gt; == &lt;expression&gt;;
    &lt;expression&gt;.EQ(&lt;expression&gt;);</pre>
<p>Lines beginning with '#' are comments. The first eight statements are
test <em>expressions</em>. The last four lines are test assertions which test
the results of two expressions. The last two are equivalent operations
using different syntax. (Note: Replace '&lt;expression&gt;' with any valid
TestML expression. '&lt;foo&gt;' is not valid TestML syntax)</p>
<dl>
<dt><strong><a name="item_test_section_3a__5b__3cws_3e__7c__3ctest_statement">test_section: [ &lt;ws&gt; | &lt;test_statement&gt; ]*</a></strong></dt>

<dd>
<p>The test section contains a small program written in the TestML
programming language. This language is used to describe
transform functions and the assertions that should hold. In other words, the
testing program.</p>
<p>The parsing of the meta section should instantiate a Test object. The
Test object will contain an abstract syntax tree that the TestML runtime
can execute.</p>
</dd>
<dt><strong><a name="item_test_statement_3a__3ctest_expression_3e__3casserti">test_statement:
    &lt;test_expression&gt;
    &lt;assertion_expression&gt;?
    /&lt;SEMI&gt;/</a></strong></dt>

<dd>
<p>A test statement is a processing directive for running tests. A
statement can either be a single test expression, which causes code to
run but doesn't execute tests, or it can be an assertion which runs a
test operation by comparing the results of two data expressions.</p>
</dd>
<dt><strong><a name="item_test_expression_3a__3csub_expression_3e__5b__3c_21">test_expression:
    &lt;sub_expression&gt;
    [
        &lt;!assertion_call_test&gt;
        &lt;call_indicator&gt;
        &lt;sub_expression&gt;
    ]*</a></strong></dt>

<dd>
<p>A test expression is a series of one or more sub expressions which are
evaluated in order, passing the result of each to the next one.</p>
</dd>
<dt><strong><a name="item_sub_expression_3a__3cpoint_call_3e__7c__3cstring_c">sub_expression:
    &lt;point_call&gt; |
    &lt;string_call&gt; |
    &lt;transform_call&gt;</a></strong></dt>

<dd>
<p>A sub expression is a chained set of transform function calls. Points
and strings are special cases of these calls. All sub expressions are
turned into transform calls after compilation. For example:</p>
<pre>
   *foo.bar(&quot;baz&quot;) == True;</pre>
<p>becomes (internally):</p>
<pre>
   Point('foo').bar(String(&quot;baz&quot;)).EQ(True());</pre>
</dd>
<dt><strong><a name="item_point_call_3a__3cstar_3e__3clower_3e__3cword_3e_2a">point_call: &lt;STAR&gt; &lt;LOWER&gt; &lt;WORD&gt;*</a></strong></dt>

<dd>
<p>A data point is a user defined data name, preceded by a '*' and
beginning with a lower case letter.</p>
<p>A data point is really a short form for a transform call to 'Point' with
the point name. These two statements are the same:</p>
<pre>
    *foo.bar;
    Point('foo').bar();</pre>
<p>except that the asterisk point names are also used to select the data
blocks that will apply to that expression.</p>
<p>Statements with points in them apply to all matching blocks. For
example, this TestML statement:</p>
<pre>
    *foo.bar == *baz;</pre>
<p>would behave like this TestMLesque pseudo-code:</p>
<pre>
    for block in SelectDataBlocks('foo', 'baz') {
        Assert(block.Point('foo').bar() == block.Point('baz'));
    }</pre>
<p>NOTE: The above code is <strong>NOT</strong> valid TestML.</p>
</dd>
<dt><strong><a name="item_string_call_3a__3cquoted_string_3e">string_call: &lt;quoted_string&gt;</a></strong></dt>

<dd>
<p>A quoted string can be used anywhere in a test expression, but it is
usually used as an argument passed to a transform function.</p>
<pre>
    'O my word!'.Split.Join('-') == 'O-my-word';</pre>
</dd>
<dt><strong><a name="item_transform_call_3a__3ctransform_name_3e__3ctransfor">transform_call:
    &lt;transform_name&gt;
    &lt;transform_argument_list&gt;?</a></strong></dt>

<dd>
<p>A transform call consists of a transform name, possibly followed by
parenthesized arguments.</p>
</dd>
<dt><strong><a name="item_transform_name_3a__3cuser_transform_3e__7c__3ccore">transform_name: &lt;user_transform&gt; | &lt;core_transform&gt;</a></strong></dt>

<dd>
<p>A transform is either a standard core one, or a user defined transform.</p>
</dd>
<dt><strong><a name="item_user_transform_3a__3clower_3e__3cword_3e_2a">user_transform: &lt;LOWER&gt; &lt;WORD&gt;*</a></strong></dt>

<dd>
<p>A user data transform name is an identifier that begins with a lower
case letter. These transforms are user defined in the bridge class.</p>
</dd>
<dt><strong><a name="item_core_transform_3a__3cupper_3e__3cword_3e_2a">core_transform: &lt;UPPER&gt; &lt;WORD&gt;*</a></strong></dt>

<dd>
<p>A core data transform is a name beginning with an upper case letter. It
refers to a constant value defined in the TestML Standard Library, which
contains things like True, False and Null.</p>
</dd>
<dt><strong><a name="item_call_indicator_3a__5b_3cdot_3e__3cws_3e_2a__7c__3c">call_indicator: [&lt;DOT&gt; &lt;ws&gt;* | &lt;ws&gt;* &lt;DOT&gt;]</a></strong></dt>

<dd>
<p>A call indicator is a period between two sub expressions. The period
must be adjecent to one of the sub expressions.</p>
</dd>
<dt><strong><a name="item_transform_argument_list_3a__3clparen_3e__3cws_3e_2">transform_argument_list:
    &lt;LPAREN&gt; &lt;ws&gt;*
    &lt;transform_arguments&gt;?
    &lt;ws&gt;* &lt;RPAREN&gt;</a></strong></dt>

<dd>
<p>A parenthesized list of zero or more arguments, where each argument is a
sub-expression.</p>
</dd>
<dt><strong><a name="item_transform_arguments_3a__3ctransform_argument_3e__5">transform_arguments:
    &lt;transform_argument&gt;
    [ &lt;ws&gt;* &lt;COMMA&gt; &lt;ws&gt;* &lt;transform_argument&gt; ]*</a></strong></dt>

<dd>
<p>The above two rules can be combined when Pegex has better syntax for lists.</p>
</dd>
<dt><strong><a name="item_transform_argument_3a__3csub_expression_3e">transform_argument: &lt;sub_expression&gt;</a></strong></dt>

<dd>
<p>Any sub-expression can be a transform function argument.</p>
</dd>
<dt><strong><a name="item_assertion_call_test_3a__2f_3ccall_indicator_3e_28_">assertion_call_test:
    /&lt;call_indicator&gt;(?:EQ|OK|HAS)&lt;LPAREN&gt;/</a></strong></dt>

<dd>
<p>This rule is a quick test to see if an assertion follows.</p>
</dd>
<dt><strong><a name="item_assertion_call_3a__3cassertion_eq_3e__7c__3cassert">assertion_call:
    &lt;assertion_eq&gt; |
    &lt;assertion_ok&gt; |
    &lt;assertion_has&gt;</a></strong></dt>

<dd>
<p>There are three types of assertions: EQ, OK and HAS. An assertion call
is a declaration of a testing operation. A typical assertion looks like:</p>
<pre>
    *input_point.transform1.transform2(arguments) == *expected_output_point;</pre>
<p>An assertion expression can either be an inline operator expression:</p>
<pre>
    *foo == *bar;</pre>
<p>or a function call:</p>
<pre>
    *foo.EQ(*bar);</pre>
</dd>
<dt><strong><a name="item_assertion_eq_3a__3cassertion_operator_eq_3e__7c__3">assertion_eq:
    &lt;assertion_operator_eq&gt; |
    &lt;assertion_function_eq&gt;</a></strong></dt>

<dd>
<p>The EQ assertion asserts that two expression result values are equal.</p>
</dd>
<dt><strong><a name="item_assertion_operator_eq_3a__3cws_3e_2b__3cequal_3e__">assertion_operator_eq:
    &lt;ws&gt;+ &lt;EQUAL&gt; &lt;EQUAL&gt; &lt;ws&gt;+ &lt;test_expression&gt;</a></strong></dt>

<dd>
<pre>
    *foo == *bar;</pre>
</dd>
<dt><strong><a name="item_assertion_function_eq_3a__3ccall_indicator_3e__2fe">assertion_function_eq:
    &lt;call_indicator&gt; /EQ/ &lt;LPAREN&gt; &lt;test_expression&gt; &lt;RPAREN&gt;</a></strong></dt>

<dd>
<pre>
    *foo.EQ(*bar);</pre>
</dd>
<dt><strong><a name="item_assertion_ok_3a__3cassertion_function_ok_3e">assertion_ok:
    &lt;assertion_function_ok&gt;</a></strong></dt>

<dd>
<p>The OK assertion asserts that an expression result is true.</p>
</dd>
<dt><strong><a name="item_assertion_function_ok_3a__3ccall_indicator_3e__2fo">assertion_function_ok:
    &lt;call_indicator&gt; /OK/ &lt;empty_parens&gt;?</a></strong></dt>

<dd>
<pre>
    *foo.OK;</pre>
</dd>
<dt><strong><a name="item_assertion_has_3a__3cassertion_operator_has_3e__7c_">assertion_has:
    &lt;assertion_operator_has&gt; |
    &lt;assertion_function_has&gt;</a></strong></dt>

<dd>
<p>The HAS assertion asserts that the result value string on one expression
contains the result value string of a second expression.</p>
</dd>
<dt><strong><a name="item_assertion_operator_has_3a__3cws_3e_2b__3ctilde_3e_">assertion_operator_has:
    &lt;ws&gt;+ &lt;TILDE&gt;&lt;TILDE&gt; &lt;ws&gt;+ &lt;test_expression&gt;</a></strong></dt>

<dd>
<pre>
    *foo ~~ *bar;</pre>
</dd>
<dt><strong><a name="item_assertion_function_has_3a__3ccall_indicator_3e__2f">assertion_function_has:
    &lt;call_indicator&gt; /HAS/ &lt;LPAREN&gt; &lt;test_expression&gt; &lt;RPAREN&gt;</a></strong></dt>

<dd>
<pre>
    *foo.HAS(*bar);</pre>
</dd>
<dt><strong><a name="item_empty_parens_3a__3clparen_3e__3cws_3e_2a__3crparen">empty_parens:
    &lt;LPAREN&gt;
    &lt;ws&gt;*
    &lt;RPAREN&gt;</a></strong></dt>

<dd>
<p>An optional empty set of parentheses is allowed on assertion calls that
don't take a second argument.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="data_section_of_the_grammar">Data Section of the Grammar</a></h3>
<p>The data section defines a sequence of data blocks, each of which is
mapping consisting of an optional short label phrase and a set of named
data points.</p>
<dl>
<dt><strong><a name="item_data_section_3a__3ctestml_data_section_3e__7c__3cy">data_section:
    &lt;testml_data_section&gt; |
    &lt;yaml_data_section&gt; |
    &lt;json_data_section&gt; |
    &lt;xml_data_section&gt;</a></strong></dt>

<dd>
<p>TestML defines a default data section syntax, but this section can also
be specified in YAML, JSON or XML.</p>
<p>The parsing of the data section should instantiate a Data object.</p>
</dd>
<dt><strong><a name="item_testml_data_section_3a__3c_26block_marker_3e__3cda">testml_data_section: &lt;&amp;block_marker&gt; &lt;data_block&gt;*</a></strong></dt>

<dd>
<p>The <em>TestML data section</em> starts when the data block marker is detected
at the beginning of a line and continues to the end of the file. This
section is parsed into 0-n <em>data block</em> objects.</p>
<p>Here is an example data section in TestML:</p>
<pre>
    === Test one
    --- input: abc
    --- output: 123
    === Test two
    --- input: xyz
    --- output: 321</pre>
</dd>
<dt><strong><a name="item_yaml_data_section_3a__28__3cdash_3e__3cdash_3e__3c">yaml_data_section:  ( &lt;DASH&gt; &lt;DASH&gt; &lt;DASH&gt; &lt;BLANK&gt;* &lt;EOL&gt; &lt;rest&gt; )</a></strong></dt>

<dd>
<p>Here is an example data section in YAML:</p>
<pre>
    ---
    - -label: Test one
      input: abc
      output: 123
    - -label: Test two
      input: xyz
      output: 321</pre>
</dd>
<dt><strong><a name="item_json_data_section_3a__28__3clsquare_3e__3crest_3e_">json_data_section: ( &lt;LSQUARE&gt; &lt;rest&gt; )</a></strong></dt>

<dd>
<p>Here is an example data section in JSON:</p>
<pre>
    [
      {
        &quot;-label&quot;: &quot;Test one&quot;,
        &quot;input&quot;: &quot;abc&quot;,
        &quot;output&quot;: &quot;123&quot;
      },
      {
        &quot;-label&quot;: &quot;Test two&quot;,
        &quot;input&quot;: &quot;xyz&quot;,
        &quot;output&quot;: &quot;321&quot;
      }
    ]</pre>
</dd>
<dt><strong><a name="item_xml_data_section_3a__28__3clangle_3e__3crest_3e__2">xml_data_section: ( &lt;LANGLE&gt; &lt;rest&gt; )</a></strong></dt>

<dd>
<p>Here is an example data section in XML:</p>
<pre>
    &lt;testml&gt;
      &lt;block label=&quot;Test one&quot;&gt;
        &lt;input&gt;abc&lt;/input&gt;
        &lt;output&gt;123&lt;/output&gt;
      &lt;/block&gt;
      &lt;block label=&quot;Test two&quot;&gt;
        &lt;input&gt;xyz&lt;/input&gt;
        &lt;output&gt;321&lt;/output&gt;
      &lt;/block&gt;
    &lt;/testml&gt;</pre>
</dd>
<dt><strong><a name="item_rest_3a__3call_3e_2b">rest: &lt;ALL&gt;+</a></strong></dt>

<dd>
<p>The <em>rest</em> token is simply the remainder of the text in the file.
The <em>data sections</em> are all parsed by separate parsers/grammars.</p>
</dd>
<dt><strong><a name="item_data_block_3a__3cblock_header_3e__5b__3cblank_line">data_block: &lt;block_header&gt; [ &lt;blank_line&gt; | &lt;comment&gt; ]* &lt;block_point&gt;*</a></strong></dt>

<dd>
<p>A data block in TestML syntax looks like:</p>
<pre>
    === Block Label
    --- point1: phrase data
    --- point2
    line
    data</pre>
</dd>
<dt><strong><a name="item_block_header_3a__3cblock_marker_3e__5b__3cblank_3e">block_header:
    &lt;block_marker&gt;
    [ &lt;BLANK&gt;+ &lt;block_label&gt; ]?
    &lt;BLANK&gt;* &lt;EOL&gt;</a></strong></dt>

<dd>
<p>A block header marks the start of a new block. The first one also marks
the start of the data section. It contains an optional label.</p>
<pre>
    === The next big test</pre>
</dd>
<dt><strong><a name="item_block_marker_3a__3cequal_3e__3cequal_3e__3cequal_3">block_marker:
    &lt;EQUAL&gt; &lt;EQUAL&gt; &lt;EQUAL&gt; |
    Meta.BlockMarker</a></strong></dt>

<dd>
<p>A block marker is usually <code>===</code>, but it is configurable via a meta
statement, like this:</p>
<pre>
    BlockMarker: ***</pre>
</dd>
<dt><strong><a name="item_block_label_3a__3cunquoted_string_3e">block_label: &lt;unquoted_string&gt;</a></strong></dt>

<dd>
<p>A label is a short description of the block. It can be used to label
tests at runtime.</p>
</dd>
<dt><strong><a name="item_block_point_3a__3clines_point_3e__7c__3cphrase_poi">block_point: &lt;lines_point&gt; | &lt;phrase_point&gt;</a></strong></dt>

<dd>
<p>Data block points are the pieces of raw data that TestML transforms and
compares. They come in two flavors, lines and phrases.</p>
</dd>
<dt><strong><a name="item_lines_point_3a__3cpoint_marker_3e__3cblank_3e_2b__">lines_point:
    &lt;point_marker&gt;
    &lt;BLANK&gt;+
    &lt;point_name&gt;
    &lt;BLANK&gt;* &lt;EOL&gt;
    &lt;point_lines&gt;</a></strong></dt>

<dd>
<p>A ``lines'' data point encodes a string containing zero or more lines. If
it has one or more lines it always ends with a newline.</p>
<pre>
    --- lines
    line1
    line2 (3 is blank)
    
    line4</pre>
</dd>
<dt><strong><a name="item_point_lines_3a__5b__5b_21__3cblock_marker_3e__7c__">point_lines: [ [! &lt;block_marker&gt; | &lt;point_marker&gt; ] &lt;line&gt; ]*</a></strong></dt>

<dd>
<p>All the lines before the next block or point header.</p>
</dd>
<dt><strong><a name="item_phrase_point_3a__3cpoint_marker_3e__3cblank_3e_2b_">phrase_point:
    &lt;point_marker&gt;
    &lt;BLANK&gt;+
    &lt;point_name&gt;
    &lt;COLON&gt; &lt;BLANK&gt;
    &lt;point_phrase&gt;
    &lt;EOL&gt;
    [ &lt;comment&gt; | &lt;blank_line&gt; ]*</a></strong></dt>

<dd>
<p>A ``phrase'' data point encodes a string with no newlines.</p>
<pre>
    --- phrase: This string is one line with no newline at the end.</pre>
</dd>
<dt><strong><a name="item_point_marker_3a__3cdash_3e__3cdash_3e__3cdash_3e__">point_marker:
    &lt;DASH&gt; &lt;DASH&gt; &lt;DASH&gt; |
    Meta.PointMarker</a></strong></dt>

<dd>
<p>A point marker is usually <code>---</code>, but it is configurable via a meta
statement, like this:</p>
<pre>
    %PointMarker: +++</pre>
</dd>
<dt><strong><a name="item_point_name_3a__3clower_3e__3cword_3e_2a">point_name: &lt;LOWER&gt; &lt;WORD&gt;*</a></strong></dt>

<dd>
<p>The name of this point is 'rudy':</p>
<pre>
    --- rudy: can't fail</pre>
</dd>
<dt><strong><a name="item_point_phrase_3a__3cunquoted_string_3e">point_phrase: &lt;unquoted_string&gt;</a></strong></dt>

<dd>
<p>The point phrase above is ``can't fail''.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="core_meta_keywords">Core Meta Keywords</a></h1>
<p>The following meta section keywords are supported by TestML 1.0.</p>
<dl>
<dt><strong><a name="item_testml__2d_required">TestML - <strong>required</strong></a></strong></dt>

<dd>
<p>The <code>TestML</code> meta statement is required, must be the first meta
statement and must specify a valid TestML release version number.</p>
<p>Once the version number is known by the parser, it controls how the rest
of the document is parsed. If the parser does not support the specified
version number, it must raise an exception.</p>
<p>For example:</p>
<pre>
    %TestML: 1.0</pre>
<p>As a guideline, the TestML specification authors will attempt to be
backwards compatible with version numbers that have the same first
number. So version 1.3 would be backwards compatible with 1.2, 1.1 and
1.0. Version 2.0 would probably break compatability.</p>
</dd>
<dt><strong><a name="item_title__2d_optional">Title - <em>optional</em></a></strong></dt>

<dd>
<p>The <em>Title</em> meta option specifies a short title phrase to describe the
entire TestML document.</p>
<pre>
    %Title: These are a few of my Favorite Tests!</pre>
<p>The TestML implementation is free to use this meta field as it sees fit.</p>
</dd>
<dt><strong><a name="item_data__2d_optional">Data - <em>optional</em></a></strong></dt>

<dd>
<p>The <em>Data</em> meta option can be specified zero, one or multiple times. It
names a relative file path that should be read and parsed as a data
section. The resulting sequences of all the data files are concatenated
together into the Data object.</p>
<p>By default, the inline data section comes first when other data sources are
specified. A special file path name '_' can be used to indicate the inline
data section.</p>
<p>The file extension is used to determine the format of the data section
encoded in the file.</p>
<p>Example:</p>
<pre>
    %Data: file1.tml
    %Data: file2.xml
    %Data: _
    %Data: file4.yaml</pre>
<p>The Data attribute of the Meta object is always stored as an array.</p>
</dd>
<dt><strong><a name="item_plan__2d_optional">Plan - <em>optional</em></a></strong></dt>

<dd>
<p>The <em>Plan</em> meta option specifies the expected number of tests that will
be run by the runner. If the actual number differs, the implementation
should complain or raise an exception.</p>
<pre>
    %Plan: 13</pre>
</dd>
<dt><strong><a name="item_blockmarker__2d_optional">BlockMarker - <em>optional</em></a></strong></dt>

<dd>
<p>If you choose to use the TestML data markup to encode your data section,
you can choose the character sequence to replace the default ('===').
You would wnat to do this primarily if you had '===' at the beginning of
a line in your data.</p>
<p>Setting this option causes the parser to immediately start looking for
the specified pattern to indicate the start of the data section.</p>
<pre>
    %BlockMarker: *=*</pre>
</dd>
<dt><strong><a name="item_pointmarker__2d_optional">PointMarker - <em>optional</em></a></strong></dt>

<dd>
<p>This option is the same as the BlockMarker option above, except
it is for the data point marker.</p>
<pre>
    %PointMarker: +++</pre>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="testml_standard_library">TestML Standard Library</a></h1>
<p>TestML defines a standard library specification. The standard library
must be implemented and available in every TestML implementation. The
library specification has a version number that is kept in sync with
this specification's version number.</p>
<p>The Standard Library Specification is defined in a separate document. The
latest version is available at <a href="http://testml.org/specification/standard-library/">http://testml.org/specification/standard-library/</a>.</p>
<p>
</p>
<hr />
<h1><a name="testml_runtime_specification">TestML Runtime Specification</a></h1>
<p>In order to develop a TestML implementation, one must correctly implement the
runtime processing. TestML defines a runtime specification. The runtime
specification has a version number that is kept in sync with this
specification's version number.</p>
<p>The TestML Runtime Specification is defined in a separate document. The
latest version is available at <a href="http://testml.org/specification/runtime/">http://testml.org/specification/runtime/</a>.</p>
<p>
</p>
<hr />
<h1><a name="authors">Authors</a></h1>
<p>TestML Version 1.0 was created by Ingy d√∂t Net &lt;<a href="mailto:ingy@ingy.net">ingy@ingy.net</a>&gt;</p>
<p>The spec was reviewed and/or contributed to by the following people:</p>
<ul>
<li><strong><a name="item_chris_dent">Chris Dent</a></strong>

</li>
<li><strong><a name="item_yuval_kogman">Yuval Kogman</a></strong>

</li>
<li><strong><a name="item_nick_patch">Nick Patch</a></strong>

</li>
</ul>
<p>
</p>
<hr />
<h1><a name="license">License</a></h1>
<p>This work is licensed under the Creative Commons Attribution Share Alike
License. To view a copy of this license, visit
<a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a>;
or, (b) send a letter to Creative Commons, 171 2nd Street, Suite 300,
San Francisco, California, 94105, USA.</p>
<p>
</p>
<hr />
<h1><a name="copyright">Copyright</a></h1>
<p>Copyright (c) 2009, 2010. Ingy d√∂t Net.</p>


</div>
</div>
</div>
</body>

</html>

